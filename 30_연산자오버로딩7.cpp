// 30_연산자오버로딩7.cpp
#include <iostream>
using namespace std;

// 함수 호출 연산자를 재정의할 수 있습니다.
// => 함수 객체(Functor)
class Func {
public:
    int operator()(int a, int b)
    {
        return a + b;
    }
};

int main()
{
    Func f;

    cout << f(10, 20) << endl;
    //   --------------
    //    f.operator()(10, 20)
}

// * 정리
// 정의: 객체를 대상으로 연산자를 사용하였을 경우,
//    약속된 멤버 함수 또는 일반 함수가 호출됩니다.

// * 규칙
// 1) 연산자 우선순위는 변하지 않습니다.
// 2) 피연산자의 개수도 변하지 않습니다.
// 3) 새로운 연산자를 정의할 수 있습니다.
// 4) 연산자 오버로딩이 허용되지 않는 연산자도 있습니다.
//    - ::(범위 연산자)
//    - .(접근 연산자)
//      a.foo() / a.data
//    - 3항 연산자

//  5) 연산자 오버로딩은 반드시 피연산자 중 하나는 객체 타입이어야 합니다.
//  6) 연산자 오버로딩 중에 반드시 멤버 함수를 통해서만
//     정의해야 하는 연산자가 있습니다.
//   => 클래스의 설계자만 제공할 수 있는 연산자 오버로딩
//      1) 대입 연산자
//       a = b
//      2) 호출 연산자
//       a(10, 20)
//      3) 임의 접근 연산자
//       v[0]
//       4) 객체 포인터 연산자
//        p->f()
//       5) 포인터 역참조 연산자
//        *p
